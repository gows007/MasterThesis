function [methodinfo,structs,enuminfo,ThunkLibName]=ps4000aMFile
%PS4000AMFILE Create structures to define interfaces found in 'ps4000aApi'.

%This function was generated by loadlibrary.m parser version  on Mon May 11 16:54:05 2015
%perl options:'ps4000aApi.i -outfile=ps4000aMFile.m -thunkfile=ps4000a_thunk_pcwin64.c -header=ps4000aApi.h'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival,'thunkname', ival);
MfilePath=fileparts(mfilename('fullpath'));
ThunkLibName=fullfile(MfilePath,'ps4000a_thunk_pcwin64');
% PICO_STATUS ps4000aOpenUnit ( int16_t * handle , char * serial ); 
fcns.thunkname{fcnNum}='uint32voidPtrcstringThunk';fcns.name{fcnNum}='ps4000aOpenUnit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr', 'cstring'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aOpenUnitAsync ( int16_t * status , char * serial ); 
fcns.thunkname{fcnNum}='uint32voidPtrcstringThunk';fcns.name{fcnNum}='ps4000aOpenUnitAsync'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr', 'cstring'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aOpenUnitProgress ( int16_t * handle , int16_t * progressPercent , int16_t * complete ); 
fcns.thunkname{fcnNum}='uint32voidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='ps4000aOpenUnitProgress'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr', 'int16Ptr', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetUnitInfo ( int16_t handle , char * string , int16_t stringLength , int16_t * requiredSize , PICO_INFO info ); 
fcns.thunkname{fcnNum}='uint32int16cstringint16voidPtruint32Thunk';fcns.name{fcnNum}='ps4000aGetUnitInfo'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'cstring', 'int16', 'int16Ptr', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aFlashLed ( int16_t handle , int16_t start ); 
fcns.thunkname{fcnNum}='uint32int16int16Thunk';fcns.name{fcnNum}='ps4000aFlashLed'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetChannelLed ( int16_t handle , PS4000A_CHANNEL_LED_SETTING * ledStates , uint16_t nLedStates ); 
fcns.thunkname{fcnNum}='uint32int16voidPtruint16Thunk';fcns.name{fcnNum}='ps4000aSetChannelLed'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'tPS4000AChannelLedSettingPtr', 'uint16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aIsLedFlashing ( int16_t handle , int16_t * status ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps4000aIsLedFlashing'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aCloseUnit ( int16_t handle ); 
fcns.thunkname{fcnNum}='uint32int16Thunk';fcns.name{fcnNum}='ps4000aCloseUnit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aMemorySegments ( int16_t handle , uint32_t nSegments , int32_t * nMaxSamples ); 
fcns.thunkname{fcnNum}='uint32int16uint32voidPtrThunk';fcns.name{fcnNum}='ps4000aMemorySegments'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'int32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetChannel ( int16_t handle , PS4000A_CHANNEL channel , int16_t enabled , PS4000A_COUPLING type , PS4000A_RANGE range , float analogOffset ); 
fcns.thunkname{fcnNum}='uint32int16PS4000A_CHANNELint16PS4000A_COUPLINGPS4000A_RANGEfloatThunk';fcns.name{fcnNum}='ps4000aSetChannel'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS4000AChannel', 'int16', 'enPS4000ACoupling', 'enPS4000ARange', 'single'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetBandwidthFilter ( int16_t handle , PS4000A_CHANNEL channel , PS4000A_BANDWIDTH_LIMITER bandwidth ); 
fcns.thunkname{fcnNum}='uint32int16PS4000A_CHANNELPS4000A_BANDWIDTH_LIMITERThunk';fcns.name{fcnNum}='ps4000aSetBandwidthFilter'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS4000AChannel', 'enPS4000ABandwidthLimiter'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aApplyResistanceScaling ( int16_t handle , PS4000A_CHANNEL channel , PS4000A_RANGE range , int16_t * bufferMax , int16_t * bufferMin , uint32_t buffertLth , int16_t * overflow ); 
fcns.thunkname{fcnNum}='uint32int16PS4000A_CHANNELPS4000A_RANGEvoidPtrvoidPtruint32voidPtrThunk';fcns.name{fcnNum}='ps4000aApplyResistanceScaling'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS4000AChannel', 'enPS4000ARange', 'int16Ptr', 'int16Ptr', 'uint32', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetTimebase ( int16_t handle , uint32_t timebase , int32_t noSamples , int32_t * timeIntervalNanoseconds , int32_t * maxSamples , uint32_t segmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16uint32int32voidPtrvoidPtruint32Thunk';fcns.name{fcnNum}='ps4000aGetTimebase'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'int32', 'int32Ptr', 'int32Ptr', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetTimebase2 ( int16_t handle , uint32_t timebase , int32_t noSamples , float * timeIntervalNanoseconds , int32_t * maxSamples , uint32_t segmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16uint32int32voidPtrvoidPtruint32Thunk';fcns.name{fcnNum}='ps4000aGetTimebase2'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'int32', 'singlePtr', 'int32Ptr', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetSigGenArbitrary ( int16_t handle , int32_t offsetVoltage , uint32_t pkToPk , uint32_t startDeltaPhase , uint32_t stopDeltaPhase , uint32_t deltaPhaseIncrement , uint32_t dwellCount , int16_t * arbitraryWaveform , int32_t arbitraryWaveformSize , PS4000A_SWEEP_TYPE sweepType , PS4000A_EXTRA_OPERATIONS operation , PS4000A_INDEX_MODE indexMode , uint32_t shots , uint32_t sweeps , PS4000A_SIGGEN_TRIG_TYPE triggerType , PS4000A_SIGGEN_TRIG_SOURCE triggerSource , int16_t extInThreshold ); 
fcns.thunkname{fcnNum}='uint32int16int32uint32uint32uint32uint32uint32voidPtrint32PS4000A_SWEEP_TYPEPS4000A_EXTRA_OPERATIONSPS4000A_INDEX_MODEuint32uint32PS4000A_SIGGEN_TRIG_TYPEPS4000A_SIGGEN_TRIG_SOURCEint16Thunk';fcns.name{fcnNum}='ps4000aSetSigGenArbitrary'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int32', 'uint32', 'uint32', 'uint32', 'uint32', 'uint32', 'int16Ptr', 'int32', 'enPS4000ASweepType', 'enPS4000AExtraOperations', 'enPS4000AIndexMode', 'uint32', 'uint32', 'enPS4000ASigGenTrigType', 'enPS4000ASigGenTrigSource', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetSigGenBuiltIn ( int16_t handle , int32_t offsetVoltage , uint32_t pkToPk , PS4000A_WAVE_TYPE waveType , double startFrequency , double stopFrequency , double increment , double dwellTime , PS4000A_SWEEP_TYPE sweepType , PS4000A_EXTRA_OPERATIONS operation , uint32_t shots , uint32_t sweeps , PS4000A_SIGGEN_TRIG_TYPE triggerType , PS4000A_SIGGEN_TRIG_SOURCE triggerSource , int16_t extInThreshold ); 
fcns.thunkname{fcnNum}='uint32int16int32uint32PS4000A_WAVE_TYPEdoubledoubledoubledoublePS4000A_SWEEP_TYPEPS4000A_EXTRA_OPERATIONSuint32uint32PS4000A_SIGGEN_TRIG_TYPEPS4000A_SIGGEN_TRIG_SOURCEint16Thunk';fcns.name{fcnNum}='ps4000aSetSigGenBuiltIn'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int32', 'uint32', 'enPS4000AWaveType', 'double', 'double', 'double', 'double', 'enPS4000ASweepType', 'enPS4000AExtraOperations', 'uint32', 'uint32', 'enPS4000ASigGenTrigType', 'enPS4000ASigGenTrigSource', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetSigGenPropertiesArbitrary ( int16_t handle , uint32_t startDeltaPhase , uint32_t stopDeltaPhase , uint32_t deltaPhaseIncrement , uint32_t dwellCount , PS4000A_SWEEP_TYPE sweepType , uint32_t shots , uint32_t sweeps , PS4000A_SIGGEN_TRIG_TYPE triggerType , PS4000A_SIGGEN_TRIG_SOURCE triggerSource , int16_t extInThreshold ); 
fcns.thunkname{fcnNum}='uint32int16uint32uint32uint32uint32PS4000A_SWEEP_TYPEuint32uint32PS4000A_SIGGEN_TRIG_TYPEPS4000A_SIGGEN_TRIG_SOURCEint16Thunk';fcns.name{fcnNum}='ps4000aSetSigGenPropertiesArbitrary'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'uint32', 'uint32', 'uint32', 'enPS4000ASweepType', 'uint32', 'uint32', 'enPS4000ASigGenTrigType', 'enPS4000ASigGenTrigSource', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetSigGenPropertiesBuiltIn ( int16_t handle , double startFrequency , double stopFrequency , double increment , double dwellTime , PS4000A_SWEEP_TYPE sweepType , uint32_t shots , uint32_t sweeps , PS4000A_SIGGEN_TRIG_TYPE triggerType , PS4000A_SIGGEN_TRIG_SOURCE triggerSource , int16_t extInThreshold ); 
fcns.thunkname{fcnNum}='uint32int16doubledoubledoubledoublePS4000A_SWEEP_TYPEuint32uint32PS4000A_SIGGEN_TRIG_TYPEPS4000A_SIGGEN_TRIG_SOURCEint16Thunk';fcns.name{fcnNum}='ps4000aSetSigGenPropertiesBuiltIn'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'double', 'double', 'double', 'double', 'enPS4000ASweepType', 'uint32', 'uint32', 'enPS4000ASigGenTrigType', 'enPS4000ASigGenTrigSource', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSigGenFrequencyToPhase ( int16_t handle , double frequency , PS4000A_INDEX_MODE indexMode , uint32_t bufferLength , uint32_t * phase ); 
fcns.thunkname{fcnNum}='uint32int16doublePS4000A_INDEX_MODEuint32voidPtrThunk';fcns.name{fcnNum}='ps4000aSigGenFrequencyToPhase'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'double', 'enPS4000AIndexMode', 'uint32', 'uint32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSigGenArbitraryMinMaxValues ( int16_t handle , int16_t * minArbitraryWaveformValue , int16_t * maxArbitraryWaveformValue , uint32_t * minArbitraryWaveformSize , uint32_t * maxArbitraryWaveformSize ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrvoidPtrvoidPtrThunk';fcns.name{fcnNum}='ps4000aSigGenArbitraryMinMaxValues'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr', 'int16Ptr', 'uint32Ptr', 'uint32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSigGenSoftwareControl ( int16_t handle , int16_t state ); 
fcns.thunkname{fcnNum}='uint32int16int16Thunk';fcns.name{fcnNum}='ps4000aSigGenSoftwareControl'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetEts ( int16_t handle , PS4000A_ETS_MODE mode , int16_t etsCycles , int16_t etsInterleave , int32_t * sampleTimePicoseconds ); 
fcns.thunkname{fcnNum}='uint32int16PS4000A_ETS_MODEint16int16voidPtrThunk';fcns.name{fcnNum}='ps4000aSetEts'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS4000AEtsMode', 'int16', 'int16', 'int32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetTriggerChannelProperties ( int16_t handle , PS4000A_TRIGGER_CHANNEL_PROPERTIES * channelProperties , int16_t nChannelProperties , int16_t auxOutputEnable , int32_t autoTriggerMilliseconds ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrint16int16int32Thunk';fcns.name{fcnNum}='ps4000aSetTriggerChannelProperties'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'tPS4000ATriggerChannelPropertiesPtr', 'int16', 'int16', 'int32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetTriggerChannelConditions ( int16_t handle , PS4000A_CONDITION * conditions , int16_t nConditions , PS4000A_CONDITIONS_INFO info ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrint16PS4000A_CONDITIONS_INFOThunk';fcns.name{fcnNum}='ps4000aSetTriggerChannelConditions'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'tPS4000AConditionPtr', 'int16', 'enPS4000AConditionsInfo'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetTriggerChannelDirections ( int16_t handle , PS4000A_DIRECTION * directions , int16_t nDirections ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrint16Thunk';fcns.name{fcnNum}='ps4000aSetTriggerChannelDirections'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'tPS4000ADirectionPtr', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetSimpleTrigger ( int16_t handle , int16_t enable , PS4000A_CHANNEL source , int16_t threshold , PS4000A_THRESHOLD_DIRECTION direction , uint32_t delay , int16_t autoTrigger_ms ); 
fcns.thunkname{fcnNum}='uint32int16int16PS4000A_CHANNELint16PS4000A_THRESHOLD_DIRECTIONuint32int16Thunk';fcns.name{fcnNum}='ps4000aSetSimpleTrigger'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16', 'enPS4000AChannel', 'int16', 'enPS4000AThresholdDirection', 'uint32', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetTriggerDelay ( int16_t handle , uint32_t delay ); 
fcns.thunkname{fcnNum}='uint32int16uint32Thunk';fcns.name{fcnNum}='ps4000aSetTriggerDelay'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetPulseWidthQualifierProperties ( int16_t handle , PS4000A_THRESHOLD_DIRECTION direction , uint32_t lower , uint32_t upper , PS4000A_PULSE_WIDTH_TYPE type ); 
fcns.thunkname{fcnNum}='uint32int16PS4000A_THRESHOLD_DIRECTIONuint32uint32PS4000A_PULSE_WIDTH_TYPEThunk';fcns.name{fcnNum}='ps4000aSetPulseWidthQualifierProperties'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS4000AThresholdDirection', 'uint32', 'uint32', 'enPS4000APulseWidthType'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetPulseWidthQualifierConditions ( int16_t handle , PS4000A_CONDITION * conditions , int16_t nConditions , PS4000A_CONDITIONS_INFO info ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrint16PS4000A_CONDITIONS_INFOThunk';fcns.name{fcnNum}='ps4000aSetPulseWidthQualifierConditions'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'tPS4000AConditionPtr', 'int16', 'enPS4000AConditionsInfo'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aIsTriggerOrPulseWidthQualifierEnabled ( int16_t handle , int16_t * triggerEnabled , int16_t * pulseWidthQualifierEnabled ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrThunk';fcns.name{fcnNum}='ps4000aIsTriggerOrPulseWidthQualifierEnabled'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetTriggerTimeOffset ( int16_t handle , uint32_t * timeUpper , uint32_t * timeLower , uint32_t * timeUnits , uint32_t segmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrvoidPtruint32Thunk';fcns.name{fcnNum}='ps4000aGetTriggerTimeOffset'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'uint32Ptr', 'uint32Ptr', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetTriggerTimeOffset64 ( int16_t handle , int64_t * time , uint32_t * timeUnits , uint32_t segmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtruint32Thunk';fcns.name{fcnNum}='ps4000aGetTriggerTimeOffset64'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int64Ptr', 'uint32Ptr', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetValuesTriggerTimeOffsetBulk ( int16_t handle , uint32_t * timesUpper , uint32_t * timesLower , PS4000A_TIME_UNITS * timeUnits , uint32_t fromSegmentIndex , uint32_t toSegmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrvoidPtruint32uint32Thunk';fcns.name{fcnNum}='ps4000aGetValuesTriggerTimeOffsetBulk'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'uint32Ptr', 'enPS4000ATimeUnitsPtr', 'uint32', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetValuesTriggerTimeOffsetBulk64 ( int16_t handle , int64_t * times , PS4000A_TIME_UNITS * timeUnits , uint32_t fromSegmentIndex , uint32_t toSegmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtruint32uint32Thunk';fcns.name{fcnNum}='ps4000aGetValuesTriggerTimeOffsetBulk64'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int64Ptr', 'enPS4000ATimeUnitsPtr', 'uint32', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetDataBuffers ( int16_t handle , PS4000A_CHANNEL channel , int16_t * bufferMax , int16_t * bufferMin , int32_t bufferLth , uint32_t segmentIndex , PS4000A_RATIO_MODE mode ); 
fcns.thunkname{fcnNum}='uint32int16PS4000A_CHANNELvoidPtrvoidPtrint32uint32PS4000A_RATIO_MODEThunk';fcns.name{fcnNum}='ps4000aSetDataBuffers'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS4000AChannel', 'int16Ptr', 'int16Ptr', 'int32', 'uint32', 'enPS4000ARatioMode'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetDataBuffer ( int16_t handle , PS4000A_CHANNEL channel , int16_t * buffer , int32_t bufferLth , uint32_t segmentIndex , PS4000A_RATIO_MODE mode ); 
fcns.thunkname{fcnNum}='uint32int16PS4000A_CHANNELvoidPtrint32uint32PS4000A_RATIO_MODEThunk';fcns.name{fcnNum}='ps4000aSetDataBuffer'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS4000AChannel', 'int16Ptr', 'int32', 'uint32', 'enPS4000ARatioMode'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetEtsTimeBuffer ( int16_t handle , int64_t * buffer , int32_t bufferLth ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrint32Thunk';fcns.name{fcnNum}='ps4000aSetEtsTimeBuffer'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int64Ptr', 'int32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetEtsTimeBuffers ( int16_t handle , uint32_t * timeUpper , uint32_t * timeLower , int32_t bufferLth ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='ps4000aSetEtsTimeBuffers'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'uint32Ptr', 'int32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aIsReady ( int16_t handle , int16_t * ready ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps4000aIsReady'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aRunBlock ( int16_t handle , int32_t noOfPreTriggerSamples , int32_t noOfPostTriggerSamples , uint32_t timebase , int32_t * timeIndisposedMs , uint32_t segmentIndex , void * lpReady , void * pParameter ); 
fcns.thunkname{fcnNum}='uint32int16int32int32uint32voidPtruint32voidPtrvoidPtrThunk';fcns.name{fcnNum}='ps4000aRunBlock'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int32', 'int32', 'uint32', 'int32Ptr', 'uint32', 'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aRunStreaming ( int16_t handle , uint32_t * sampleInterval , PS4000A_TIME_UNITS sampleIntervalTimeUnits , uint32_t maxPreTriggerSamples , uint32_t maxPostTriggerSamples , int16_t autoStop , uint32_t downSampleRatio , PS4000A_RATIO_MODE downSampleRatioMode , uint32_t overviewBufferSize ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrPS4000A_TIME_UNITSuint32uint32int16uint32PS4000A_RATIO_MODEuint32Thunk';fcns.name{fcnNum}='ps4000aRunStreaming'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'enPS4000ATimeUnits', 'uint32', 'uint32', 'int16', 'uint32', 'enPS4000ARatioMode', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetStreamingLatestValues ( int16_t handle , void * lpPs4000aReady , void * pParameter ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrvoidPtrThunk';fcns.name{fcnNum}='ps4000aGetStreamingLatestValues'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aNoOfStreamingValues ( int16_t handle , uint32_t * noOfValues ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps4000aNoOfStreamingValues'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetMaxDownSampleRatio ( int16_t handle , uint32_t noOfUnaggreatedSamples , uint32_t * maxDownSampleRatio , PS4000A_RATIO_MODE downSampleRatioMode , uint32_t segmentIndex ); 
fcns.thunkname{fcnNum}='uint32int16uint32voidPtrPS4000A_RATIO_MODEuint32Thunk';fcns.name{fcnNum}='ps4000aGetMaxDownSampleRatio'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'uint32Ptr', 'enPS4000ARatioMode', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetValues ( int16_t handle , uint32_t startIndex , uint32_t * noOfSamples , uint32_t downSampleRatio , PS4000A_RATIO_MODE downSampleRatioMode , uint32_t segmentIndex , int16_t * overflow ); 
fcns.thunkname{fcnNum}='uint32int16uint32voidPtruint32PS4000A_RATIO_MODEuint32voidPtrThunk';fcns.name{fcnNum}='ps4000aGetValues'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'uint32Ptr', 'uint32', 'enPS4000ARatioMode', 'uint32', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetValuesAsync ( int16_t handle , uint32_t startIndex , uint32_t noOfSamples , uint32_t downSampleRatio , PS4000A_RATIO_MODE downSampleRatioMode , uint32_t segmentIndex , void * lpDataReady , void * pParameter ); 
fcns.thunkname{fcnNum}='uint32int16uint32uint32uint32PS4000A_RATIO_MODEuint32voidPtrvoidPtrThunk';fcns.name{fcnNum}='ps4000aGetValuesAsync'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'uint32', 'uint32', 'enPS4000ARatioMode', 'uint32', 'voidPtr', 'voidPtr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetValuesBulk ( int16_t handle , uint32_t * noOfSamples , uint32_t fromSegmentIndex , uint32_t toSegmentIndex , uint32_t downSampleRatio , PS4000A_RATIO_MODE downSampleRatioMode , int16_t * overflow ); 
fcns.thunkname{fcnNum}='uint32int16voidPtruint32uint32uint32PS4000A_RATIO_MODEvoidPtrThunk';fcns.name{fcnNum}='ps4000aGetValuesBulk'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr', 'uint32', 'uint32', 'uint32', 'enPS4000ARatioMode', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetValuesOverlapped ( int16_t handle , uint32_t startIndex , uint32_t * noOfSamples , uint32_t downSampleRatio , PS4000A_RATIO_MODE downSampleRatioMode , uint32_t segmentIndex , int16_t * overflow ); 
fcns.thunkname{fcnNum}='uint32int16uint32voidPtruint32PS4000A_RATIO_MODEuint32voidPtrThunk';fcns.name{fcnNum}='ps4000aGetValuesOverlapped'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'uint32Ptr', 'uint32', 'enPS4000ARatioMode', 'uint32', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetValuesOverlappedBulk ( int16_t handle , uint32_t startIndex , uint32_t * noOfSamples , uint32_t downSampleRatio , PS4000A_RATIO_MODE downSampleRatioMode , uint32_t fromSegmentIndex , uint32_t toSegmentIndex , int16_t * overflow ); 
fcns.thunkname{fcnNum}='uint32int16uint32voidPtruint32PS4000A_RATIO_MODEuint32uint32voidPtrThunk';fcns.name{fcnNum}='ps4000aGetValuesOverlappedBulk'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32', 'uint32Ptr', 'uint32', 'enPS4000ARatioMode', 'uint32', 'uint32', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aEnumerateUnits ( int16_t * count , char * serials , int16_t * serialLth ); 
fcns.thunkname{fcnNum}='uint32voidPtrcstringvoidPtrThunk';fcns.name{fcnNum}='ps4000aEnumerateUnits'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16Ptr', 'cstring', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetChannelInformation ( int16_t handle , PS4000A_CHANNEL_INFO info , int32_t probe , int32_t * ranges , int32_t * length , int32_t channels ); 
fcns.thunkname{fcnNum}='uint32int16PS4000A_CHANNEL_INFOint32voidPtrvoidPtrint32Thunk';fcns.name{fcnNum}='ps4000aGetChannelInformation'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS4000AChannelInfo', 'int32', 'int32Ptr', 'int32Ptr', 'int32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aConnectDetect ( int16_t handle , PS4000A_CONNECT_DETECT * sensor , int16_t nSensors ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrint16Thunk';fcns.name{fcnNum}='ps4000aConnectDetect'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'tPS4000AConnectDetectPtr', 'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aMaximumValue ( int16_t handle , int16_t * value ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps4000aMaximumValue'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aMinimumValue ( int16_t handle , int16_t * value ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps4000aMinimumValue'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'int16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetAnalogueOffset ( int16_t handle , PS4000A_RANGE range , PS4000A_COUPLING coupling , float * maximumVoltage , float * minimumVoltage ); 
fcns.thunkname{fcnNum}='uint32int16PS4000A_RANGEPS4000A_COUPLINGvoidPtrvoidPtrThunk';fcns.name{fcnNum}='ps4000aGetAnalogueOffset'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS4000ARange', 'enPS4000ACoupling', 'singlePtr', 'singlePtr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetMaxSegments ( int16_t handle , uint32_t * maxSegments ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps4000aGetMaxSegments'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aChangePowerSource ( int16_t handle , PICO_STATUS powerState ); 
fcns.thunkname{fcnNum}='uint32int16uint32Thunk';fcns.name{fcnNum}='ps4000aChangePowerSource'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aCurrentPowerSource ( int16_t handle ); 
fcns.thunkname{fcnNum}='uint32int16Thunk';fcns.name{fcnNum}='ps4000aCurrentPowerSource'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aStop ( int16_t handle ); 
fcns.thunkname{fcnNum}='uint32int16Thunk';fcns.name{fcnNum}='ps4000aStop'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aPingUnit ( int16_t handle ); 
fcns.thunkname{fcnNum}='uint32int16Thunk';fcns.name{fcnNum}='ps4000aPingUnit'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetNoOfCaptures ( int16_t handle , uint32_t nCaptures ); 
fcns.thunkname{fcnNum}='uint32int16uint32Thunk';fcns.name{fcnNum}='ps4000aSetNoOfCaptures'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetNoOfCaptures ( int16_t handle , uint32_t * nCaptures ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps4000aGetNoOfCaptures'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetNoOfProcessedCaptures ( int16_t handle , uint32_t * nProcessedCaptures ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps4000aGetNoOfProcessedCaptures'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aDeviceMetaData ( int16_t handle , char * settings , int32_t * nSettingsLength , PS4000A_META_TYPE type , PS4000A_META_OPERATION operation , PS4000A_META_FORMAT format ); 
fcns.thunkname{fcnNum}='uint32int16cstringvoidPtrPS4000A_META_TYPEPS4000A_META_OPERATIONPS4000A_META_FORMATThunk';fcns.name{fcnNum}='ps4000aDeviceMetaData'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'cstring', 'int32Ptr', 'enPS4000AMetaType', 'enPS4000AMetaOperation', 'enPS4000AMetaFormat'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetString ( int16_t handle , PICO_STRING_VALUE stringValue , char * string , int32_t * stringLength ); 
fcns.thunkname{fcnNum}='uint32int16PICO_STRING_VALUEcstringvoidPtrThunk';fcns.name{fcnNum}='ps4000aGetString'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPicoStringValue', 'cstring', 'int32Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aGetCommonModeOverflow ( int16_t handle , uint16_t * overflow ); 
fcns.thunkname{fcnNum}='uint32int16voidPtrThunk';fcns.name{fcnNum}='ps4000aGetCommonModeOverflow'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'uint16Ptr'};fcnNum=fcnNum+1;
% PICO_STATUS ps4000aSetFrequencyCounter ( int16_t handle , PS4000A_CHANNEL channel , int16_t enabled , PS4000A_FREQUENCY_COUNTER_RANGE range , int16_t thresholdMajor , int16_t thresholdMinor ); 
fcns.thunkname{fcnNum}='uint32int16PS4000A_CHANNELint16PS4000A_FREQUENCY_COUNTER_RANGEint16int16Thunk';fcns.name{fcnNum}='ps4000aSetFrequencyCounter'; fcns.calltype{fcnNum}='Thunk'; fcns.LHS{fcnNum}='uint32'; fcns.RHS{fcnNum}={'int16', 'enPS4000AChannel', 'int16', 'enPS4000AFrequencyCounterRange', 'int16', 'int16'};fcnNum=fcnNum+1;
structs.tPS4000AChannelLedSetting.packing=1;
structs.tPS4000AChannelLedSetting.members=struct('channel', 'enPS4000AChannel', 'state', 'enPS4000AChannelLed');
structs.tPS4000ADirection.packing=1;
structs.tPS4000ADirection.members=struct('channel', 'enPS4000AChannel', 'direction', 'enPS4000AThresholdDirection');
structs.tPS4000ACondition.packing=1;
structs.tPS4000ACondition.members=struct('source', 'enPS4000AChannel', 'condition', 'enPS4000ATriggerState');
structs.tPS4000ATriggerChannelProperties.packing=1;
structs.tPS4000ATriggerChannelProperties.members=struct('thresholdUpper', 'int16', 'thresholdUpperHysteresis', 'uint16', 'thresholdLower', 'int16', 'thresholdLowerHysteresis', 'uint16', 'channel', 'enPS4000AChannel', 'thresholdMode', 'enPS4000AThresholdMode');
structs.tPS4000AConnectDetect.packing=1;
structs.tPS4000AConnectDetect.members=struct('channel', 'enPS4000AChannel', 'state', 'enPS4000ASensorState');
enuminfo.enPS4000ATriggerState=struct('PS4000A_CONDITION_DONT_CARE',0,'PS4000A_CONDITION_TRUE',1,'PS4000A_CONDITION_FALSE',2,'PS4000A_CONDITION_MAX',3);
enuminfo.enPS4000AThresholdMode=struct('PS4000A_LEVEL',0,'PS4000A_WINDOW',1);
enuminfo.enPS4000AEtsMode=struct('PS4000A_ETS_OFF',0,'PS4000A_ETS_FAST',1,'PS4000A_ETS_SLOW',2,'PS4000A_ETS_MODES_MAX',3);
enuminfo.enPS4000AChannel=struct('PS4000A_CHANNEL_A',0,'PS4000A_CHANNEL_B',1,'PS4000A_CHANNEL_C',2,'PS4000A_CHANNEL_D',3,'PS4000A_MAX_4_CHANNELS',4,'PS4000A_CHANNEL_E',4,'PS4000A_CHANNEL_F',5,'PS4000A_CHANNEL_G',6,'PS4000A_CHANNEL_H',7,'PS4000A_EXTERNAL',8,'PS4000A_MAX_CHANNELS',8,'PS4000A_TRIGGER_AUX',9,'PS4000A_MAX_TRIGGER_SOURCES',10,'PS4000A_PULSE_WIDTH_SOURCE',268435456);
enuminfo.enPS4000ARange=struct('PS4000A_10MV',0,'PS4000A_20MV',1,'PS4000A_50MV',2,'PS4000A_100MV',3,'PS4000A_200MV',4,'PS4000A_500MV',5,'PS4000A_1V',6,'PS4000A_2V',7,'PS4000A_5V',8,'PS4000A_10V',9,'PS4000A_20V',10,'PS4000A_50V',11,'PS4000A_100V',12,'PS4000A_200V',13,'PS4000A_MAX_RANGES',14);
enuminfo.enPS4000ASigGenTrigSource=struct('PS4000A_SIGGEN_NONE',0,'PS4000A_SIGGEN_SCOPE_TRIG',1,'PS4000A_SIGGEN_AUX_IN',2,'PS4000A_SIGGEN_EXT_IN',3,'PS4000A_SIGGEN_SOFT_TRIG',4);
enuminfo.enPS4000ASweepType=struct('PS4000A_UP',0,'PS4000A_DOWN',1,'PS4000A_UPDOWN',2,'PS4000A_DOWNUP',3,'PS4000A_MAX_SWEEP_TYPES',4);
enuminfo.enPS4000ACoupling=struct('PS4000A_AC',0,'PS4000A_DC',1);
enuminfo.enPS4000ABandwidthLimiter=struct('PS4000A_BW_FULL',0,'PS4000A_BW_20KHZ',1);
enuminfo.enPS4000AIndexMode=struct('PS4000A_SINGLE',0,'PS4000A_DUAL',1,'PS4000A_QUAD',2,'PS4000A_MAX_INDEX_MODES',3);
enuminfo.enPS4000APulseWidthType=struct('PS4000A_PW_TYPE_NONE',0,'PS4000A_PW_TYPE_LESS_THAN',1,'PS4000A_PW_TYPE_GREATER_THAN',2,'PS4000A_PW_TYPE_IN_RANGE',3,'PS4000A_PW_TYPE_OUT_OF_RANGE',4);
enuminfo.enPS4000ATimeUnits=struct('PS4000A_FS',0,'PS4000A_PS',1,'PS4000A_NS',2,'PS4000A_US',3,'PS4000A_MS',4,'PS4000A_S',5,'PS4000A_MAX_TIME_UNITS',6);
enuminfo.enPS4000AMetaOperation=struct('PS4000A_MO_READ',0,'PS4000A_MO_WRITE',1);
enuminfo.enPS4000AChannelLed=struct('PS4000A_CHANNEL_LED_OFF',0,'PS4000A_CHANNEL_LED_RED',1,'PS4000A_CHANNEL_LED_GREEN',2);
enuminfo.enPS4000AWaveType=struct('PS4000A_SINE',0,'PS4000A_SQUARE',1,'PS4000A_TRIANGLE',2,'PS4000A_RAMP_UP',3,'PS4000A_RAMP_DOWN',4,'PS4000A_SINC',5,'PS4000A_GAUSSIAN',6,'PS4000A_HALF_SINE',7,'PS4000A_DC_VOLTAGE',8,'PS4000A_WHITE_NOISE',9,'PS4000A_MAX_WAVE_TYPES',10);
enuminfo.enPS4000AFrequencyCounterRange=struct('PS4000A_FC_2K',0,'PS4000A_FC_20K',1,'PS4000A_FC_20',2,'PS4000A_FC_200',3,'PS4000A_FC_MAX',4);
enuminfo.enPS4000AChannelBufferIndex=struct('PS4000A_CHANNEL_A_MAX',0,'PS4000A_CHANNEL_A_MIN',1,'PS4000A_CHANNEL_B_MAX',2,'PS4000A_CHANNEL_B_MIN',3,'PS4000A_CHANNEL_C_MAX',4,'PS4000A_CHANNEL_C_MIN',5,'PS4000A_CHANNEL_D_MAX',6,'PS4000A_CHANNEL_D_MIN',7,'PS4000A_CHANNEL_E_MAX',8,'PS4000A_CHANNEL_E_MIN',9,'PS4000A_CHANNEL_F_MAX',10,'PS4000A_CHANNEL_F_MIN',11,'PS4000A_CHANNEL_G_MAX',12,'PS4000A_CHANNEL_G_MIN',13,'PS4000A_CHANNEL_H_MAX',14,'PS4000A_CHANNEL_H_MIN',15,'PS4000A_MAX_CHANNEL_BUFFERS',16);
enuminfo.enPS4000ASensorState=struct('PS4000A_CONNECT_STATE_FLOATING',0,'PS4000A_SENSOR_STATE_CONNECTED',1);
enuminfo.enPS4000ARatioMode=struct('PS4000A_RATIO_MODE_NONE',0,'PS4000A_RATIO_MODE_AGGREGATE',1,'PS4000A_RATIO_MODE_DECIMATE',2,'PS4000A_RATIO_MODE_AVERAGE',4,'PS4000A_RATIO_MODE_DISTRIBUTION',8);
enuminfo.enPS4000AResistanceRange=struct('PS4000A_RESISTANCE_315K',512,'PS4000A_RESISTANCE_1100K',513,'PS4000A_RESISTANCE_10M',514,'PS4000A_MAX_RESISTANCE_RANGES',3,'PS4000A_RESISTANCE_ADCV',268435456);
enuminfo.enPS4000AExtraOperations=struct('PS4000A_ES_OFF',0,'PS4000A_WHITENOISE',1,'PS4000A_PRBS',2);
enuminfo.enPS4000ASigGenTrigType=struct('PS4000A_SIGGEN_RISING',0,'PS4000A_SIGGEN_FALLING',1,'PS4000A_SIGGEN_GATE_HIGH',2,'PS4000A_SIGGEN_GATE_LOW',3);
enuminfo.enPS4000AChannelInfo=struct('PS4000A_CI_RANGES',0,'PS4000A_CI_RESISTANCES',1);
enuminfo.enPS4000AConditionsInfo=struct('PS4000A_CLEAR',1,'PS4000A_ADD',2);
enuminfo.enPS4000AThresholdDirection=struct('PS4000A_ABOVE',0,'PS4000A_BELOW',1,'PS4000A_RISING',2,'PS4000A_FALLING',3,'PS4000A_RISING_OR_FALLING',4,'PS4000A_ABOVE_LOWER',5,'PS4000A_BELOW_LOWER',6,'PS4000A_RISING_LOWER',7,'PS4000A_FALLING_LOWER',8,'PS4000A_INSIDE',0,'PS4000A_OUTSIDE',1,'PS4000A_ENTER',2,'PS4000A_EXIT',3,'PS4000A_ENTER_OR_EXIT',4,'PS4000A_POSITIVE_RUNT',9,'PS4000A_NEGATIVE_RUNT',10,'PS4000A_NONE',2);
enuminfo.enPicoStringValue=struct('PICO_SV_MEMORY',0,'PICO_SV_MEMORY_NO_OF_SEGMENTS',1,'PICO_SV_MEMORY_MAX_SAMPLES',2,'PICO_SV_NO_OF_CHANNELS',3,'PICO_SV_ARRAY_OF_CHANNELS',4,'PICO_SV_CHANNEL',5,'PICO_SV_CHANNEL_NAME',6,'PICO_SV_CHANNEL_RANGE',7,'PICO_SV_CHANNEL_COUPLING',8,'PICO_SV_CHANNEL_ENABLED',9,'PICO_SV_CHANNEL_ANALOGUE_OFFSET',10,'PICO_SV_CHANNEL_BANDWIDTH',11,'PICO_SV_TRIGGER',12,'PICO_SV_TRIGGER_AUXIO_OUTPUT_ENABLED',13,'PICO_SV_TRIGGER_AUTO_TRIGGER_MILLISECONDS',14,'PICO_SV_TRIGGER_PROPERTIES',15,'PICO_SV_NO_OF_TRIGGER_PROPERTIES',16,'PICO_SV_TRIGGER_PROPERTIES_CHANNEL',17,'PICO_SV_TRIGGER_PROPERTIES_THRESHOLD_UPPER',18,'PICO_SV_TRIGGER_PROPERTIES_THRESHOLD_UPPER_HYSTERESIS',19,'PICO_SV_TRIGGER_PROPERTIES_THRESHOLD_LOWER',20,'PICO_SV_TRIGGER_PROPERTIES_THRESHOLD_LOWER_HYSTERESIS',21,'PICO_SV_TRIGGER_PROPERTIES_THRESHOLD_MODE',22,'PICO_SV_TRIGGER_ARRAY_OF_BLOCK_CONDITIONS',23,'PICO_SV_TRIGGER_NO_OF_BLOCK_CONDITIONS',24,'PICO_SV_TRIGGER_CONDITIONS',25,'PICO_SV_TRIGGER_NO_OF_CONDITIONS',26,'PICO_SV_TRIGGER_CONDITION_SOURCE',27,'PICO_SV_TRIGGER_CONDITION_STATE',28,'PICO_SV_TRIGGER_DIRECTION',29,'PICO_SV_TRIGGER_NO_OF_DIRECTIONS',30,'PICO_SV_TRIGGER_DIRECTION_CHANNEL',31,'PICO_SV_TRIGGER_DIRECTION_DIRECTION',32,'PICO_SV_TRIGGER_DELAY',33,'PICO_SV_TRIGGER_DELAY_MS',34,'PICO_SV_FREQUENCY_COUNTER',35,'PICO_SV_FREQUENCY_COUNTER_ENABLED',36,'PICO_SV_FREQUENCY_COUNTER_CHANNEL',37,'PICO_SV_FREQUENCY_COUNTER_RANGE',38,'PICO_SV_FREQUENCY_COUNTER_TRESHOLDMAJOR',39,'PICO_SV_FREQUENCY_COUNTER_TRESHOLDMINOR',40,'PICO_SV_PULSE_WIDTH_PROPERTIES',41,'PICO_SV_PULSE_WIDTH_PROPERTIES_DIRECTION',42,'PICO_SV_PULSE_WIDTH_PROPERTIES_LOWER',43,'PICO_SV_PULSE_WIDTH_PROPERTIES_UPPER',44,'PICO_SV_PULSE_WIDTH_PROPERTIES_TYPE',45,'PICO_SV_PULSE_WIDTH_ARRAY_OF_BLOCK_CONDITIONS',46,'PICO_SV_PULSE_WIDTH_NO_OF_BLOCK_CONDITIONS',47,'PICO_SV_PULSE_WIDTH_CONDITIONS',48,'PICO_SV_PULSE_WIDTH_NO_OF_CONDITIONS',49,'PICO_SV_PULSE_WIDTH_CONDITIONS_SOURCE',50,'PICO_SV_PULSE_WIDTH_CONDITIONS_STATE',51,'PICO_SV_SAMPLE_PROPERTIES',52,'PICO_SV_SAMPLE_PROPERTIES_PRE_TRIGGER_SAMPLES',53,'PICO_SV_SAMPLE_PROPERTIES_POST_TRIGGER_SAMPLES',54,'PICO_SV_SAMPLE_PROPERTIES_TIMEBASE',55,'PICO_SV_SAMPLE_PROPERTIES_NO_OF_CAPTURES',56,'PICO_SV_SAMPLE_PROPERTIES_RESOLUTION',57,'PICO_SV_SAMPLE_PROPERTIES_OVERLAPPED',58,'PICO_SV_SAMPLE_PROPERTIES_OVERLAPPED_DOWN_SAMPLE_RATIO',59,'PICO_SV_SAMPLE_PROPERTIES_OVERLAPPED_DOWN_SAMPLE_RATIO_MODE',60,'PICO_SV_SAMPLE_PROPERTIES_OVERLAPPED_REQUERSTED_NO_OF_SAMPLES',61,'PICO_SV_SAMPLE_PROPERTIES_OVERLAPPED_SEGMENT_INDEX_FROM',62,'PICO_SV_SAMPLE_PROPERTIES_OVERLAPPED_SEGMENT_INDEX_TO',63,'PICO_SV_SIGNAL_GENERATOR',64,'PICO_SV_SIGNAL_GENERATOR_BUILT_IN',65,'PICO_SV_SIGNAL_GENERATOR_BUILT_IN_WAVE_TYPE',66,'PICO_SV_SIGNAL_GENERATOR_BUILT_IN_START_FREQUENCY',67,'PICO_SV_SIGNAL_GENERATOR_BUILT_IN_STOP_FREQUENCY',68,'PICO_SV_SIGNAL_GENERATOR_BUILT_IN_INCREMENT',69,'PICO_SV_SIGNAL_GENERATOR_BUILT_IN_DWELL_TIME',70,'PICO_SV_SIGNAL_GENERATOR_AWG',71,'PICO_SV_SIGNAL_GENERATOR_AWG_START_DELTA_PHASE',72,'PICO_SV_SIGNAL_GENERATOR_AWG_STOP_DELTA_PHASE',73,'PICO_SV_SIGNAL_GENERATOR_AWG_DELTA_PHASE_INCREMENT',74,'PICO_SV_SIGNAL_GENERATOR_AWG_DWELL_COUNT',75,'PICO_SV_SIGNAL_GENERATOR_AWG_INDEX_MODE',76,'PICO_SV_SIGNAL_GENERATOR_AWG_WAVEFORM_SIZE',77,'PICO_SV_SIGNAL_GENERATOR_ARRAY_OF_AWG_WAVEFORM_VALUES',78,'PICO_SV_SIGNAL_GENERATOR_OFFSET_VOLTAGE',79,'PICO_SV_SIGNAL_GENERATOR_PK_TO_PK',80,'PICO_SV_SIGNAL_GENERATOR_OPERATION',81,'PICO_SV_SIGNAL_GENERATOR_SHOTS',82,'PICO_SV_SIGNAL_GENERATOR_SWEEPS',83,'PICO_SV_SIGNAL_GENERATOR_SWEEP_TYPE',84,'PICO_SV_SIGNAL_GENERATOR_TRIGGER_TYPE',85,'PICO_SV_SIGNAL_GENERATOR_TRIGGER_SOURCE',86,'PICO_SV_SIGNAL_GENERATOR_EXT_IN_THRESHOLD',87,'PICO_SV_ETS',88,'PICO_SV_ETS_STATE',89,'PICO_SV_ETS_CYCLE',90,'PICO_SV_ETS_INTERLEAVE',91,'PICO_SV_ETS_SAMPLE_TIME_PICOSECONDS',92);
enuminfo.enPS4000AMetaType=struct('PS4000A_MT_UNIT_INFO',0,'PS4000A_MT_DEVICE_CAPABILITY',1,'PS4000A_MT_DEVICE_SETTINGS',2,'PS4000A_MT_SIGNAL_GENERATOR_SETTINGS',3);
enuminfo.enPS4000AMetaFormat=struct('PS4000A_MF_COMMA_SEPERATED',0,'PS4000A_MF_XML',1);
methodinfo=fcns;