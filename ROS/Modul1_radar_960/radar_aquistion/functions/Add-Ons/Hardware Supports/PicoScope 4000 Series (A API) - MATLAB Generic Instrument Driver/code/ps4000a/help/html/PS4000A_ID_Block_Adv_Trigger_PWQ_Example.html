
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>PicoScope 4000 Series (A API) Instrument Driver Oscilloscope Block Data Capture with Advanced Trigger Example</title><meta name="generator" content="MATLAB 8.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2015-08-18"><meta name="DC.source" content="PS4000A_ID_Block_ADV_Trigger_PWQ_Example.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>PicoScope 4000 Series (A API) Instrument Driver Oscilloscope Block Data Capture with Advanced Trigger Example</h1><!--introduction--><p>This is an example of an instrument control session using a device object. The instrument control session comprises all the steps you are likely to take when communicating with your instrument.</p><p>These steps are:</p><div><ol><li>Create a device object</li><li>Connect to the instrument</li><li>Configure properties</li><li>Invoke functions</li><li>Disconnect from the instrument</li></ol></div><p>To run the instrument control session, type the name of the file, PS4000A_ID_Block_Adv_Trigger_PWQ_Example, at the MATLAB command prompt.</p><p>The file, PS4000A_ID_BLOCK_ADV_TRIGGER_PWQ_EXAMPLE.M must be on your MATLAB PATH. For additional information on setting your MATLAB PATH, type 'help addpath' at the MATLAB command prompt.</p><p><b>Example:</b>     PS4000A_ID_Block_Adv_Trigger_PWQ_Example;</p><p><b>Description:</b>     Demonstrates how to call functions in order to capture a block of     data using advanced trigger functions with a pulse width qualifier     from a PicoScope 4000 Series Oscilloscope using the underlying 'A'     API.</p><p><b>See also:</b> <a href="matlab:doc('icdevice')">icdevice</a> | <a href="matlab:doc('instrument/invoke')">invoke</a></p><p><b>Copyright:</b> (C) Pico Technology Limited 2014 - 2015. All rights reserved.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Suggested Input Test Signal</a></li><li><a href="#2">Clear Command Window</a></li><li><a href="#3">Load Configuration Information</a></li><li><a href="#4">Device Connection</a></li><li><a href="#5">Set Channels</a></li><li><a href="#6">Verify Timebase Index and Maximum Number of Samples</a></li><li><a href="#7">Set Advanced Trigger with Pulse Width Qualifier</a></li><li><a href="#8">Set Block Parameters and Capture Data</a></li><li><a href="#10">Process Data</a></li><li><a href="#11">Disconnect Device</a></li></ul></div><h2>Suggested Input Test Signal<a name="1"></a></h2><p>This example was published using the following test signal:</p><div><ul><li>Channel A: 4Vpp, 2Hz square wave</li></ul></div><h2>Clear Command Window<a name="2"></a></h2><pre class="codeinput">clc;
</pre><h2>Load Configuration Information<a name="3"></a></h2><pre class="codeinput">PS4000aConfig;
</pre><h2>Device Connection<a name="4"></a></h2><pre class="codeinput"><span class="comment">% Create a device object.</span>
<span class="comment">% The serial number can be specified as a second input parameter.</span>
ps4000aDeviceObj = icdevice(<span class="string">'picotech_ps4000a_generic.mdd'</span>, <span class="string">''</span>);

<span class="comment">% Connect device object to hardware.</span>
connect(ps4000aDeviceObj);
</pre><pre class="codeoutput">
Copyright (C) Pico Technology Ltd. 2014 - 2015

PicoScope 4000 Series (A API) MATLAB Instrument Driver

Number of units found: 1

Serial number(s): CQ451/999

Opening PicoScope 4000 Series device...

   Instrument Device Object Using Driver : picotech_ps4000a_generic.mdd
 
   Instrument Information
      Type:               Oscilloscope
      Manufacturer:       Pico Technology Ltd.
      Model:              PicoScope 4000 Series (A API)
 
   Driver Information
      DriverType:         MATLAB generic
      DriverName:         picotech_ps4000a_generic.mdd
      DriverVersion:      1.1.26
 
   Communication State
      Status:             open

Setting Device Parameters...

Default Channel Setup:-
-----------------------

Channel A:-
	Enabled: True
	Coupling: DC
	Range: 5V
	Analogue Offset: 0.0V

Channel B:-
	Enabled: True
	Coupling: DC
	Range: 5V
	Analogue Offset: 0.0V

Channel C:-
	Enabled: True
	Coupling: DC
	Range: 5V
	Analogue Offset: 0.0V

Channel D:-
	Enabled: True
	Coupling: DC
	Range: 5V
	Analogue Offset: 0.0V

Channel E:-
	Enabled: True
	Coupling: DC
	Range: 5V
	Analogue Offset: 0.0V

Channel F:-
	Enabled: True
	Coupling: DC
	Range: 5V
	Analogue Offset: 0.0V

Channel G:-
	Enabled: True
	Coupling: DC
	Range: 5V
	Analogue Offset: 0.0V

Channel H:-
	Enabled: True
	Coupling: DC
	Range: 5V
	Analogue Offset: 0.0V

Turning off trigger...

Default Block mode parameters:-

               Timebase index : 79
                 Time Interval: 1000.0 ns
 Number of pre-trigger samples: 0
Number of post-trigger samples: 1000000
       Total number of samples: 1000000

Default Streaming mode parameters:-

 Streaming interval: 1.00e-06 s
Streaming auto stop: 1

Default Signal generator parameters:-

      Start frequency: 1000 Hz
       Stop frequency: 1000 Hz
       Offset voltage: 0 mV
 Peak to Peak voltage: 2000 mV

Initialisation complete.

Connected to PicoScope 4000 Series device:-

      Instrument Model: 4824
   Batch/Serial Number: CQ451/999
     Analogue Channels: 8
             Bandwidth: 20 MHz
         Buffer memory: 256 MS
 Maximum sampling rate: 80 MS/s
 Signal Generator Type: Arbitrary Waveform Generator

</pre><h2>Set Channels<a name="5"></a></h2><pre class="codeinput"><span class="comment">% Default driver settings applied to channels are listed below -</span>
<span class="comment">% use ps4000aSetChannel to turn channels on or off and set voltage ranges,</span>
<span class="comment">% coupling, as well as analogue offset.</span>

<span class="comment">% In this example, data is only collected on Channel A so default settings</span>
<span class="comment">% are used and channels B to H are switched off.</span>

<span class="comment">% Channels       : 1 - 7 (ps4000aEnuminfo.enPS4000AChannel.PS4000A_CHANNEL_B - PS4000A_CHANNEL_H)</span>
<span class="comment">% Enabled        : 0</span>
<span class="comment">% Type           : 1 (ps4000aEnuminfo.enPS4000ACoupling.PS4000A_DC)</span>
<span class="comment">% Range          : 8 (ps4000aEnuminfo.enPS4000ARange.PS4000A_5V)</span>
<span class="comment">% Analogue Offset: 0.0</span>

<span class="comment">% Execute device object function(s).</span>
[status.setChB] = invoke(ps4000aDeviceObj, <span class="string">'ps4000aSetChannel'</span>, 1, 0, 1, 8, 0.0);

<span class="keyword">if</span>(ps4000aDeviceObj.channelCount == PicoConstants.QUAD_SCOPE || ps4000aDeviceObj.channelCount == PicoConstants.OCTO_SCOPE)

    [status.setChC] = invoke(ps4000aDeviceObj, <span class="string">'ps4000aSetChannel'</span>, 2, 0, 1, 8, 0.0);
    [status.setChD] = invoke(ps4000aDeviceObj, <span class="string">'ps4000aSetChannel'</span>, 3, 0, 1, 8, 0.0);

<span class="keyword">end</span>

<span class="keyword">if</span>(ps4000aDeviceObj.channelCount == PicoConstants.OCTO_SCOPE)

    [status.setChE] = invoke(ps4000aDeviceObj, <span class="string">'ps4000aSetChannel'</span>, 4, 0, 1, 8, 0.0);
    [status.setChF] = invoke(ps4000aDeviceObj, <span class="string">'ps4000aSetChannel'</span>, 5, 0, 1, 8, 0.0);
    [status.setChG] = invoke(ps4000aDeviceObj, <span class="string">'ps4000aSetChannel'</span>, 6, 0, 1, 8, 0.0);
    [status.setChH] = invoke(ps4000aDeviceObj, <span class="string">'ps4000aSetChannel'</span>, 7, 0, 1, 8, 0.0);

<span class="keyword">end</span>
</pre><h2>Verify Timebase Index and Maximum Number of Samples<a name="6"></a></h2><p>Driver default timebase index used - use ps4000aGetTimebase2 to query the driver as to suitability of using a particular timebase index and the maximum number of samples available in the segment selected (the buffer memory has not been segmented in this example) then set the 'timebase' property if required.</p><p>To use the fastest sampling interval possible, set one analogue channel and turn off all other channels.</p><p>Use a while loop to query the function until the status indicates that a valid timebase index has been selected. In this example, the timebase index of 79 is valid.</p><pre class="codeinput"><span class="comment">% Initial call to ps4000aGetTimebase2 with parameters:</span>
<span class="comment">% timebase      : 79</span>
<span class="comment">% segment index : 0</span>

status.getTimebase2 = PicoStatus.PICO_INVALID_TIMEBASE;
timebaseIndex = get(ps4000aDeviceObj, <span class="string">'timebase'</span>);

<span class="keyword">while</span>(status.getTimebase2 == PicoStatus.PICO_INVALID_TIMEBASE)

    [status.getTimebase2, timeIntervalNanoSeconds, maxSamples] = invoke(ps4000aDeviceObj, <span class="string">'ps4000aGetTimebase2'</span>, timebaseIndex, 0);

    <span class="keyword">if</span>(status.getTimebase2 == PicoStatus.PICO_OK)

        <span class="keyword">break</span>;

    <span class="keyword">else</span>

        timebaseIndex = timebaseIndex + 1;

    <span class="keyword">end</span>

<span class="keyword">end</span>

set(ps4000aDeviceObj, <span class="string">'timebase'</span>, timebaseIndex);
</pre><h2>Set Advanced Trigger with Pulse Width Qualifier<a name="7"></a></h2><p>This example demonstrates the configuration of an advanced trigger with pulse width qualifer in order to set up a Level Dropout Trigger on Channel A when a signal falls below a threshold and stays low for a period of time greater than that specified. <b>Note:</b> Trigger conditions may be set on up to a maximum of FOUR channels.</p><pre class="codeinput"><span class="comment">% Trigger properties and functions are located in the Instrument</span>
<span class="comment">% Driver's Trigger group.</span>
triggerGroupObj = get(ps4000aDeviceObj, <span class="string">'Trigger'</span>);
triggerGroupObj = triggerGroupObj(1);

<span class="comment">% Set the autoTriggerMs property in order to automatically trigger the</span>
<span class="comment">% oscilloscope after 1 second if a trigger event has not occurred. Set to 0</span>
<span class="comment">% to wait indefinitely for a trigger event.</span>

set(triggerGroupObj, <span class="string">'autoTriggerMs'</span>, 1000);

<span class="comment">% Trigger Channel Properties:</span>
<span class="comment">% ---------------------------</span>

<span class="comment">% Obtain a Trigger Channel Properties structure from the ps4000aMfile prototype file</span>
triggerChannelProperties = ps4000aStructs.tPS4000ATriggerChannelProperties.members;

<span class="comment">% Obtain the voltage range (in millivolts) for Channel A</span>
chARangeMv = PicoConstants.SCOPE_INPUT_RANGES(ps4000aEnuminfo.enPS4000ARange.PS4000A_5V + 1);

<span class="comment">% Set the properties</span>
triggerChannelProperties.thresholdUpper             = mv2adc(500, chARangeMv, ps4000aDeviceObj.maxADCValue);
triggerChannelProperties.thresholdUpperHysteresis   = mv2adc(40, chARangeMv, ps4000aDeviceObj.maxADCValue);
triggerChannelProperties.thresholdLower             = mv2adc(500, chARangeMv, ps4000aDeviceObj.maxADCValue);
triggerChannelProperties.thresholdLowerHysteresis   = mv2adc(40, chARangeMv, ps4000aDeviceObj.maxADCValue);
triggerChannelProperties.channel                    = ps4000aEnuminfo.enPS4000AChannel.PS4000A_CHANNEL_A;
triggerChannelProperties.thresholdMode              = ps4000aEnuminfo.enPS4000AThresholdMode.PS4000A_LEVEL;

<span class="comment">% Trigger Directions</span>
<span class="comment">% ------------------</span>

<span class="comment">% Use a tPS4000ADirection struct in order to set the directions for each</span>
<span class="comment">% channel.</span>
triggerDirection            = ps4000aStructs.tPS4000ADirection.members;
triggerDirection.channel    = ps4000aEnuminfo.enPS4000AChannel.PS4000A_CHANNEL_A;
triggerDirection.direction  = ps4000aEnuminfo.enPS4000AThresholdDirection.PS4000A_ABOVE;

disp(<span class="string">'Setting advanced trigger parameters...'</span>)

<span class="comment">% Set the advanced trigger properies and direction(s)</span>
advancedTriggerStatus = invoke(triggerGroupObj, <span class="string">'setAdvancedTrigger'</span>, <span class="keyword">...</span>
                            triggerChannelProperties, triggerDirection);

<span class="comment">% The info parameter clears and adds the conditions to the trigger. If an</span>
<span class="comment">% 'OR' trigger condition is required call setTriggerChannelConditions</span>
<span class="comment">% multiple times with the info parameter set to the PS4000A_ADD enumeration.</span>
<span class="comment">% The bitor function can also be used here e.g. info = bitor(ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_CLEAR, ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_ADD);</span>
info = ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_CLEAR + ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_ADD;

<span class="comment">% Trigger Channel Conditions</span>
<span class="comment">% --------------------------</span>

<span class="comment">% Set up trigger conditions on the scope's inputs. An array of two</span>
<span class="comment">% condition tPS4000ACondition structs is required here to indicate a</span>
<span class="comment">% trigger AND pulse width qualifier condition.</span>
triggerCondition(1) =  ps4000aStructs.tPS4000ACondition.members;
triggerCondition(2) =  ps4000aStructs.tPS4000ACondition.members;

<span class="comment">% In this example, the threshold level of Channel A is used with the Pulse</span>
<span class="comment">% Width Qualifier, so the condition is set to the</span>
<span class="comment">% PS4000A_CONDITION_DONT_CARE enumeration.</span>
triggerCondition(1).source      = ps4000aEnuminfo.enPS4000AChannel.PS4000A_CHANNEL_A;
triggerCondition(1).condition   = ps4000aEnuminfo.enPS4000ATriggerState.PS4000A_CONDITION_DONT_CARE;

triggerCondition(2).source      = ps4000aEnuminfo.enPS4000AChannel.PS4000A_PULSE_WIDTH_SOURCE;
triggerCondition(2).condition   = ps4000aEnuminfo.enPS4000ATriggerState.PS4000A_CONDITION_TRUE;

triggerConditionStatus = invoke(triggerGroupObj, <span class="string">'setTriggerChannelConditions'</span>, <span class="keyword">...</span>
                            triggerCondition, info);

<span class="comment">% Pulse Width Qualifer (PWQ)</span>
<span class="comment">% --------------------------</span>

pwqTriggerCondition             =  ps4000aStructs.tPS4000ACondition.members;
pwqTriggerCondition.source      = ps4000aEnuminfo.enPS4000AChannel.PS4000A_CHANNEL_A;
pwqTriggerCondition.condition   = ps4000aEnuminfo.enPS4000ATriggerState.PS4000A_CONDITION_TRUE;

<span class="comment">% PWQ Properties:</span>
<span class="comment">% The info parameter clears and adds the conditions to the PWQ. If an</span>
<span class="comment">% 'OR' condition is required call setPulseWidthQualifier</span>
<span class="comment">% multiple times with the info parameter set to the PS4000A_ADD enumeration.</span>

pwqInfo     = ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_CLEAR + ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_ADD;
pwDirection = ps4000aEnuminfo.enPS4000AThresholdDirection.PS4000A_ABOVE;

<span class="comment">% Calculate the lower and upper thresholds as the number of samples based</span>
<span class="comment">% on the desired time period and selected sampling interval. For example,</span>
<span class="comment">% the lower limit is set to 100000 - at 1us, this is 100ms - this can be set</span>
<span class="comment">% as (totalTimeInNanoSeconds / timeIntervalNanoSeconds = 100e6 / 1000).</span>
lower       = 100000;
upper       = 10;

<span class="comment">% If the lower limit is exceeded, the PWQ condition will be met.</span>
type        = ps4000aEnuminfo.enPS4000APulseWidthType.PS4000A_PW_TYPE_GREATER_THAN;

pwqStatus = invoke(triggerGroupObj, <span class="string">'setPulseWidthQualifier'</span>, <span class="keyword">...</span>
                pwqTriggerCondition, pwqInfo, pwDirection, lower, upper, type);
</pre><pre class="codeoutput">Setting advanced trigger parameters...
</pre><h2>Set Block Parameters and Capture Data<a name="8"></a></h2><p>Capture a block of data and retrieve data values for Channel A.</p><pre class="codeinput"><span class="comment">% Block data acquisition properties and functions are located in the</span>
<span class="comment">% Instrument Driver's Block group.</span>

blockGroupObj = get(ps4000aDeviceObj, <span class="string">'Block'</span>);
blockGroupObj = blockGroupObj(1);

<span class="comment">% Set pre-trigger and post-trigger samples as required.</span>
set(ps4000aDeviceObj, <span class="string">'numPreTriggerSamples'</span>, 0);
set(ps4000aDeviceObj, <span class="string">'numPostTriggerSamples'</span>, 2e6);
</pre><p>This example uses the <i>runBlock</i> function in order to collect a block of data - if other code needs to be executed while waiting for the device to indicate that it is ready, use the <i>ps4000aRunBlock</i> function and poll the <i>ps4000aIsReady</i> function.</p><pre class="codeinput"><span class="comment">% Capture a block of data:</span>
<span class="comment">%</span>
<span class="comment">% segment index: 0 (The buffer memory is not segmented in this example)</span>

[status.runBlock] = invoke(blockGroupObj, <span class="string">'runBlock'</span>, 0);

<span class="comment">% Retrieve data values:</span>
<span class="comment">%</span>
<span class="comment">% start index       : 0</span>
<span class="comment">% segment index     : 0</span>
<span class="comment">% downsampling ratio: 1</span>
<span class="comment">% downsampling mode : 0 (ps4000aEnuminfo.enPS4000ARatioMode.PS4000A_RATIO_MODE_NONE)</span>

<span class="comment">% Provide additional output arguments for the remaining channels e.g. chB</span>
<span class="comment">% for Channel B</span>
[numSamples, overflow, chA] = invoke(blockGroupObj, <span class="string">'getBlockData'</span>, 0, 0, 1, 0);

<span class="comment">% Stop the device</span>
[status.stop] = invoke(ps4000aDeviceObj, <span class="string">'ps4000aStop'</span>);
</pre><pre class="codeoutput">runBlock:- Collecting block of data:
	Timebase: 79
	Pre-trigger samples: 0
	Post-trigger samples: 2000000
runBlock: Waiting for device to become ready...
runBlock: Device ready.

getBlockData: Setting up data buffers...
getBlockData: Retrieving data...
getBlockData: Assigning data to array and converting to millivolts.
getBlockData: Data succesfully retrieved.
</pre><h2>Process Data<a name="10"></a></h2><p>Plot data values returned from the device.</p><pre class="codeinput">figure1 = figure(<span class="string">'Name'</span>,<span class="string">'PicoScope 4000 Series Example - Block Mode Capture with Adv. Trigger &amp; PWQ'</span>, <span class="keyword">...</span>
    <span class="string">'NumberTitle'</span>, <span class="string">'off'</span>);

axes1 = gca;

<span class="comment">% Calculate sampling interval (nanoseconds) and convert to milliseconds</span>
<span class="comment">% Use the timeIntervalNanoSeconds output from the ps4000aGetTimebase2</span>
<span class="comment">% function or calculate it using the main Programmer's Guide.</span>

timeNs = double(timeIntervalNanoSeconds) * double(0:numSamples - 1);
timeMs = timeNs / 1e6;

<span class="comment">% Channel A</span>
plot(axes1, timeMs, chA);
ylim(axes1, [(-1 * chARangeMv) chARangeMv]);

<span class="comment">% Plot the trigger position</span>
hold(axes1, <span class="string">'on'</span>);
triggerPosn = (numSamples)/2 + 1;
plot(axes1, timeMs(triggerPosn), chA(triggerPosn), <span class="string">'rx'</span>);

title(axes1, <span class="string">'Block Data Acquisition'</span>);
xlabel(axes1, <span class="string">'Time (ms)'</span>);
ylabel(axes1, <span class="string">'Voltage (mV)'</span>);

grid(axes1, <span class="string">'on'</span>);
legend(axes1, <span class="string">'Channel A'</span>);
</pre><img vspace="5" hspace="5" src="PS4000A_ID_Block_ADV_Trigger_PWQ_Example_01.png" alt=""> <h2>Disconnect Device<a name="11"></a></h2><p>Disconnect device object from hardware.</p><pre class="codeinput">disconnect(ps4000aDeviceObj);
delete(ps4000aDeviceObj);
</pre><pre class="codeoutput">Connection to PicoScope 4824 with serial number CQ451/999 closed successfully.
Libraries unloaded successfully.
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% PicoScope 4000 Series (A API) Instrument Driver Oscilloscope Block Data Capture with Advanced Trigger Example
% This is an example of an instrument control session using a device 
% object. The instrument control session comprises all the steps you 
% are likely to take when communicating with your instrument. 
%       
% These steps are:
%   
% # Create a device object   
% # Connect to the instrument 
% # Configure properties 
% # Invoke functions 
% # Disconnect from the instrument 
%
% To run the instrument control session, type the name of the file,
% PS4000A_ID_Block_Adv_Trigger_PWQ_Example, at the MATLAB command prompt.
% 
% The file, PS4000A_ID_BLOCK_ADV_TRIGGER_PWQ_EXAMPLE.M must be on your MATLAB
% PATH. For additional information on setting your MATLAB PATH, type 'help
% addpath' at the MATLAB command prompt.
%
% *Example:*
%     PS4000A_ID_Block_Adv_Trigger_PWQ_Example;
%
% *Description:*
%     Demonstrates how to call functions in order to capture a block of
%     data using advanced trigger functions with a pulse width qualifier
%     from a PicoScope 4000 Series Oscilloscope using the underlying 'A'
%     API.
%
% *See also:* <matlab:doc('icdevice') icdevice> | <matlab:doc('instrument/invoke') invoke>
%
% *Copyright:* (C) Pico Technology Limited 2014 - 2015. All rights reserved.

%% Suggested Input Test Signal
% This example was published using the following test signal:
%
% * Channel A: 4Vpp, 2Hz square wave

%% Clear Command Window

clc;

%% Load Configuration Information

PS4000aConfig;

%% Device Connection

% Create a device object. 
% The serial number can be specified as a second input parameter.
ps4000aDeviceObj = icdevice('picotech_ps4000a_generic.mdd', '');

% Connect device object to hardware.
connect(ps4000aDeviceObj);

%% Set Channels

% Default driver settings applied to channels are listed below - 
% use ps4000aSetChannel to turn channels on or off and set voltage ranges, 
% coupling, as well as analogue offset.

% In this example, data is only collected on Channel A so default settings
% are used and channels B to H are switched off.

% Channels       : 1 - 7 (ps4000aEnuminfo.enPS4000AChannel.PS4000A_CHANNEL_B - PS4000A_CHANNEL_H)
% Enabled        : 0
% Type           : 1 (ps4000aEnuminfo.enPS4000ACoupling.PS4000A_DC)
% Range          : 8 (ps4000aEnuminfo.enPS4000ARange.PS4000A_5V)
% Analogue Offset: 0.0

% Execute device object function(s).
[status.setChB] = invoke(ps4000aDeviceObj, 'ps4000aSetChannel', 1, 0, 1, 8, 0.0);

if(ps4000aDeviceObj.channelCount == PicoConstants.QUAD_SCOPE || ps4000aDeviceObj.channelCount == PicoConstants.OCTO_SCOPE)

    [status.setChC] = invoke(ps4000aDeviceObj, 'ps4000aSetChannel', 2, 0, 1, 8, 0.0);
    [status.setChD] = invoke(ps4000aDeviceObj, 'ps4000aSetChannel', 3, 0, 1, 8, 0.0);

end

if(ps4000aDeviceObj.channelCount == PicoConstants.OCTO_SCOPE)

    [status.setChE] = invoke(ps4000aDeviceObj, 'ps4000aSetChannel', 4, 0, 1, 8, 0.0);
    [status.setChF] = invoke(ps4000aDeviceObj, 'ps4000aSetChannel', 5, 0, 1, 8, 0.0);
    [status.setChG] = invoke(ps4000aDeviceObj, 'ps4000aSetChannel', 6, 0, 1, 8, 0.0);
    [status.setChH] = invoke(ps4000aDeviceObj, 'ps4000aSetChannel', 7, 0, 1, 8, 0.0);

end

%% Verify Timebase Index and Maximum Number of Samples
% Driver default timebase index used - use ps4000aGetTimebase2 to query the
% driver as to suitability of using a particular timebase index and the
% maximum number of samples available in the segment selected (the buffer
% memory has not been segmented in this example) then set the 'timebase'
% property if required.
%
% To use the fastest sampling interval possible, set one analogue channel
% and turn off all other channels.
%
% Use a while loop to query the function until the status indicates that a
% valid timebase index has been selected. In this example, the timebase 
% index of 79 is valid. 

% Initial call to ps4000aGetTimebase2 with parameters:
% timebase      : 79
% segment index : 0

status.getTimebase2 = PicoStatus.PICO_INVALID_TIMEBASE;
timebaseIndex = get(ps4000aDeviceObj, 'timebase');

while(status.getTimebase2 == PicoStatus.PICO_INVALID_TIMEBASE)

    [status.getTimebase2, timeIntervalNanoSeconds, maxSamples] = invoke(ps4000aDeviceObj, 'ps4000aGetTimebase2', timebaseIndex, 0);
    
    if(status.getTimebase2 == PicoStatus.PICO_OK)
       
        break;
        
    else
        
        timebaseIndex = timebaseIndex + 1;
        
    end

end

set(ps4000aDeviceObj, 'timebase', timebaseIndex);

%% Set Advanced Trigger with Pulse Width Qualifier
% This example demonstrates the configuration of an advanced trigger with
% pulse width qualifer in order to set up a Level Dropout Trigger on
% Channel A when a signal falls below a threshold and stays low for a
% period of time greater than that specified.
% *Note:* Trigger conditions may be set on up to a maximum of FOUR channels.

% Trigger properties and functions are located in the Instrument
% Driver's Trigger group.
triggerGroupObj = get(ps4000aDeviceObj, 'Trigger');
triggerGroupObj = triggerGroupObj(1);

% Set the autoTriggerMs property in order to automatically trigger the
% oscilloscope after 1 second if a trigger event has not occurred. Set to 0
% to wait indefinitely for a trigger event.

set(triggerGroupObj, 'autoTriggerMs', 1000);

% Trigger Channel Properties:
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

% Obtain a Trigger Channel Properties structure from the ps4000aMfile prototype file
triggerChannelProperties = ps4000aStructs.tPS4000ATriggerChannelProperties.members;

% Obtain the voltage range (in millivolts) for Channel A
chARangeMv = PicoConstants.SCOPE_INPUT_RANGES(ps4000aEnuminfo.enPS4000ARange.PS4000A_5V + 1);

% Set the properties
triggerChannelProperties.thresholdUpper             = mv2adc(500, chARangeMv, ps4000aDeviceObj.maxADCValue);
triggerChannelProperties.thresholdUpperHysteresis   = mv2adc(40, chARangeMv, ps4000aDeviceObj.maxADCValue);
triggerChannelProperties.thresholdLower             = mv2adc(500, chARangeMv, ps4000aDeviceObj.maxADCValue);
triggerChannelProperties.thresholdLowerHysteresis   = mv2adc(40, chARangeMv, ps4000aDeviceObj.maxADCValue);
triggerChannelProperties.channel                    = ps4000aEnuminfo.enPS4000AChannel.PS4000A_CHANNEL_A;
triggerChannelProperties.thresholdMode              = ps4000aEnuminfo.enPS4000AThresholdMode.PS4000A_LEVEL;

% Trigger Directions
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

% Use a tPS4000ADirection struct in order to set the directions for each
% channel. 
triggerDirection            = ps4000aStructs.tPS4000ADirection.members;
triggerDirection.channel    = ps4000aEnuminfo.enPS4000AChannel.PS4000A_CHANNEL_A;
triggerDirection.direction  = ps4000aEnuminfo.enPS4000AThresholdDirection.PS4000A_ABOVE;

disp('Setting advanced trigger parameters...')

% Set the advanced trigger properies and direction(s)
advancedTriggerStatus = invoke(triggerGroupObj, 'setAdvancedTrigger', ...
                            triggerChannelProperties, triggerDirection);

% The info parameter clears and adds the conditions to the trigger. If an
% 'OR' trigger condition is required call setTriggerChannelConditions
% multiple times with the info parameter set to the PS4000A_ADD enumeration.
% The bitor function can also be used here e.g. info = bitor(ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_CLEAR, ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_ADD);
info = ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_CLEAR + ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_ADD;

% Trigger Channel Conditions
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

% Set up trigger conditions on the scope's inputs. An array of two
% condition tPS4000ACondition structs is required here to indicate a
% trigger AND pulse width qualifier condition.
triggerCondition(1) =  ps4000aStructs.tPS4000ACondition.members;
triggerCondition(2) =  ps4000aStructs.tPS4000ACondition.members;

% In this example, the threshold level of Channel A is used with the Pulse
% Width Qualifier, so the condition is set to the
% PS4000A_CONDITION_DONT_CARE enumeration.
triggerCondition(1).source      = ps4000aEnuminfo.enPS4000AChannel.PS4000A_CHANNEL_A;
triggerCondition(1).condition   = ps4000aEnuminfo.enPS4000ATriggerState.PS4000A_CONDITION_DONT_CARE;

triggerCondition(2).source      = ps4000aEnuminfo.enPS4000AChannel.PS4000A_PULSE_WIDTH_SOURCE;
triggerCondition(2).condition   = ps4000aEnuminfo.enPS4000ATriggerState.PS4000A_CONDITION_TRUE;

triggerConditionStatus = invoke(triggerGroupObj, 'setTriggerChannelConditions', ...
                            triggerCondition, info);

% Pulse Width Qualifer (PWQ)
% REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH

pwqTriggerCondition             =  ps4000aStructs.tPS4000ACondition.members;
pwqTriggerCondition.source      = ps4000aEnuminfo.enPS4000AChannel.PS4000A_CHANNEL_A;
pwqTriggerCondition.condition   = ps4000aEnuminfo.enPS4000ATriggerState.PS4000A_CONDITION_TRUE;

% PWQ Properties:
% The info parameter clears and adds the conditions to the PWQ. If an
% 'OR' condition is required call setPulseWidthQualifier
% multiple times with the info parameter set to the PS4000A_ADD enumeration.

pwqInfo     = ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_CLEAR + ps4000aEnuminfo.enPS4000AConditionsInfo.PS4000A_ADD;
pwDirection = ps4000aEnuminfo.enPS4000AThresholdDirection.PS4000A_ABOVE; 

% Calculate the lower and upper thresholds as the number of samples based
% on the desired time period and selected sampling interval. For example,
% the lower limit is set to 100000 - at 1us, this is 100ms - this can be set
% as (totalTimeInNanoSeconds / timeIntervalNanoSeconds = 100e6 / 1000).
lower       = 100000;
upper       = 10;

% If the lower limit is exceeded, the PWQ condition will be met.
type        = ps4000aEnuminfo.enPS4000APulseWidthType.PS4000A_PW_TYPE_GREATER_THAN; 

pwqStatus = invoke(triggerGroupObj, 'setPulseWidthQualifier', ...
                pwqTriggerCondition, pwqInfo, pwDirection, lower, upper, type);

%% Set Block Parameters and Capture Data
% Capture a block of data and retrieve data values for Channel A.

% Block data acquisition properties and functions are located in the 
% Instrument Driver's Block group.

blockGroupObj = get(ps4000aDeviceObj, 'Block');
blockGroupObj = blockGroupObj(1);

% Set pre-trigger and post-trigger samples as required.
set(ps4000aDeviceObj, 'numPreTriggerSamples', 0);
set(ps4000aDeviceObj, 'numPostTriggerSamples', 2e6);

%%
% This example uses the _runBlock_ function in order to collect a block of
% data - if other code needs to be executed while waiting for the device to
% indicate that it is ready, use the _ps4000aRunBlock_ function and poll
% the _ps4000aIsReady_ function.

% Capture a block of data:
%
% segment index: 0 (The buffer memory is not segmented in this example)

[status.runBlock] = invoke(blockGroupObj, 'runBlock', 0);

% Retrieve data values:
%
% start index       : 0
% segment index     : 0
% downsampling ratio: 1
% downsampling mode : 0 (ps4000aEnuminfo.enPS4000ARatioMode.PS4000A_RATIO_MODE_NONE)

% Provide additional output arguments for the remaining channels e.g. chB
% for Channel B
[numSamples, overflow, chA] = invoke(blockGroupObj, 'getBlockData', 0, 0, 1, 0);

% Stop the device
[status.stop] = invoke(ps4000aDeviceObj, 'ps4000aStop');

%% Process Data
% Plot data values returned from the device.

figure1 = figure('Name','PicoScope 4000 Series Example - Block Mode Capture with Adv. Trigger & PWQ', ...
    'NumberTitle', 'off');

axes1 = gca;

% Calculate sampling interval (nanoseconds) and convert to milliseconds
% Use the timeIntervalNanoSeconds output from the ps4000aGetTimebase2
% function or calculate it using the main Programmer's Guide.

timeNs = double(timeIntervalNanoSeconds) * double(0:numSamples - 1);
timeMs = timeNs / 1e6;

% Channel A
plot(axes1, timeMs, chA);
ylim(axes1, [(-1 * chARangeMv) chARangeMv]);

% Plot the trigger position
hold(axes1, 'on');
triggerPosn = (numSamples)/2 + 1;
plot(axes1, timeMs(triggerPosn), chA(triggerPosn), 'rx');

title(axes1, 'Block Data Acquisition');
xlabel(axes1, 'Time (ms)');
ylabel(axes1, 'Voltage (mV)');

grid(axes1, 'on');
legend(axes1, 'Channel A');

%% Disconnect Device
% Disconnect device object from hardware.

disconnect(ps4000aDeviceObj);
delete(ps4000aDeviceObj);

##### SOURCE END #####
--></body></html>